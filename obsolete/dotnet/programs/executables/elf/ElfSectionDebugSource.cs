using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace EmbedEmul.Elf
{
    /// <summary>
    /// The first entry in the .debug_srcinfo section for each compilation unit
    /// consists of five 4-byte words of data.  The contents of these five words
    /// should be interpreted (by debuggers) as follows:
    ///
    /// 	(1)	The starting address (relative to the entire .line section)
    /// 		of the .line section for this compilation unit.
    ///
    /// 	(2)	The starting address (relative to the entire .debug_sfnames
    /// 		section) of the .debug_sfnames section for this compilation
    /// 		unit.
    ///
    /// 	(3)	The starting address (in the execution virtual address space)
    /// 		of the .text section for this compilation unit.
    ///
    /// 	(4)	The ending address plus one (in the execution virtual address
    /// 		space) of the .text section for this compilation unit.
    ///
    /// 	(5)	The date/time (in seconds since midnight 1/1/70) at which the
    /// 		compilation of this compilation unit occurred.  This value
    /// 	 	should be interpreted as an unsigned quantity because gcc
    /// 		might be configured to generate a default value of 0xffffffff
    /// 		in this field (in cases where it is desired to have object
    /// 		files created at different times from identical source files
    /// 		be byte-for-byte identical).  By default, these timestamps
    /// 		are *not* generated by dwarfout.c (so that object files
    /// 		compiled at different times will be byte-for-byte identical).
    /// 		If you wish to enable this "timestamp" feature however, you
    /// 		can simply place a #define for the symbol `DWARF_TIMESTAMPS'
    /// 		in your target configuration file and then rebuild the GNU
    /// 		compiler(s).
    /// 		
    /// Each normal entry in the .debug_srcinfo section consists of two 4-byte
    /// words of data as follows:
    ///
    /// 	(1)	The starting address (relative to the entire .line section)
    /// 		of the first .line entry in the relevant LEC.
    ///
    /// 	(2)	The starting address (relative to the entire .debug_sfnames
    /// 		section) of a NUL terminated string representing the
    /// 		relevant filename.  (This filename name be either a
    /// 		relative or an absolute filename, depending upon how the
    /// 		given source file was located during compilation.)
    ///
    /// Obviously, each .debug_srcinfo entry allows you to find the relevant filename,
    /// and it also points you to the first .line entry that was generated as a result
    /// of having compiled a given source line from the given source file.
    /// 
    /// The .debug_srcinfo section associated with each compilation will also have
    /// a specialized terminating entry.  This terminating .debug_srcinfo section
    /// entry will consist of the following two 4-byte words of data:
    ///
    /// 	(1)	The offset, measured from the start of the .line section to
    /// 		the beginning of the terminating entry for the .line section.
    ///
    /// 	(2)	A word containing the value 0xffffffff.
    /// </summary>
    public class ElfSectionDebugSource : ElfSection
    {
        UInt32[] _fileLineOffset;
        UInt32[] _fileNameOffset;

        public ElfSectionDebugSource(ElfHeader context, ElfSectionHeader header, System.IO.BinaryReader reader)
            : base(context, header, reader) 
        {
            long len = _data.BufferLength >> 3; //div 8

            _fileLineOffset = new UInt32[len];
            _fileNameOffset = new UInt32[len];

            ByteOrder order = context.ByteOrder;
            for(int ii = 0; ii < len; ii++)
            {
                _fileLineOffset[ii] = _data.GetUInt32();
                _fileNameOffset[ii] = _data.GetUInt32();
            }

            //release data
            _data = null;
        }
    }
}
